\section{Entwicklungsprozess} % (fold)
\label{sec:entwicklungsprozess}

Bei dem Entwicklungsprozess wurde auf mehrere professionelle Elemente besonderen Wert gelegt. Diese sollen im Folgenden kurz erläutert werden.
\subsection{Werkzeuge} % (fold)
\label{sub:werkzeuge}
\paragraph{Versionsverwaltung} % (fold)
\label{par:versionsverwaltung}
Eine der grundlegendsten Dinge bei der Softwareentwicklung ist ein Versionskontrollsystem. In diesem Projekt wurde dafür \emph{Git} verwendet und in einem Repository auf Github (\url{https://github.com/Knorrke/MazeRunner}) veröffentlicht. Dies ermöglichte zum einen unkompliziert das Arbeiten auf mehreren Geräten. Zum anderen konnte durch das Erstellen neuer Branches seperat an Features entwickelt werden, ohne die Hauptversion während dem Entwicklungsprozess zu verändern. Über Pull Requests wurden die Features dann in den Hauptzweig gemergt.
% paragraph versionsverwaltung (end)

\paragraph{Dependency Management} % (fold)
\label{par:dependency_management}
Um nicht jedes Mal das Rad neu zu erfinden, ist es oft sinnvoll, existierende Bibliotheken zu verwenden. Damit das Projekt leicht auf anderen PCs eingerichtet werden kann, sollte das Einbinden von solchen Abhängigkeiten durch ein Verwaltungssystem geschehen. Dafür wurde \emph{Maven} verwendet, das ebenfalls eine Buildautomatisierung ermöglichte.
% paragraph dependency_management (end)

\paragraph{Continuous Integration} % (fold)
\label{par:continuous_integration}
Mit einem Continuous Integration Service (in diesem Fall \emph{Travis CI}) konnte sichergestellt werden, dass die Tests nicht nur auf dem eigenen Gerät funktionieren, sowie dass Pull Requests vollständig funktionsfähig sind, bevor sie in den Hauptzweig eingebunden werden. Des Weiteren ließ sich dadurch das Testcoverage Tool \emph{JaCoCo} integrieren (Genaueres siehe \ref{sub:testgetriebene_entwicklung}).
% paragraph continuous_integration (end)
% subsection werkzeuge (end)

\subsection{Agile Softwareentwicklung} % (fold)
\label{sub:agile_softwareentwicklung}
Die Entwicklung und Planung der Software lief agil ab. Es wurde also in kleineren Etappen (Sprints) gearbeitet, die mit einer Auswahl der wichtigsten Issues aus Kundensicht begannen und an deren Ende immer funktionsfähige Produkte standen. Wichtiger Bestandteil davon war das Issue-System von Github, sowie die Zuordnung zu Meilensteinen und Releases für die Zwischenversionen. Eine Ausbauung hätte das Kanban-Board (Github Projects) ermöglicht, in dem die Issues gefiltert und priorisiert in Spalten abgelegt werden können. Das hätte noch mehr Ähnlichkeit zum Sprint Backlog gehabt, der jetzt nur unpriorisiert in Meilensteinen umgesetzt wurde. Die inkrementellen Produkterweiterungen ermöglichten frühzeitige Usertests, die auch die Priorisierung für die weitere Entwicklung festlegten.

% subsection agile_softwareentwicklung (end)
\subsection{Testgetriebene Entwicklung} % (fold)
\label{sub:testgetriebene_entwicklung}

Für die Gewährleistung der Funktionalität und Absicherung für Änderungen sind Unit-Tests enorm hilfreich. Sie verkürzen die Zeit zur Fehlersuche, da Fehler direkt mit einem Knopfdruck angezeigt werden können. Außerdem geben sie dem Entwickler die Sicherheit bei größeren Strukturänderungen, dass das System danach noch die Anforderungen erfüllt. Das Projekt wurde komplett testgetrieben entwickelt, was bedeutet, dass nicht mit der Implementierung begonnen wird und dann ein Test dazu geschrieben wird, sondern umgekehrt: Zuerst definiert ein Test, wie sich der Code verhalten soll, anschließend wird dieser Test so einfach wie möglich erfüllt. Dadurch wird sichergestellt, dass nur Code geschrieben wird, der auch wirklich notwendig ist. In einer dritten Phase, dem Refactoring, wird der Code anschließend nochmal bzgl Code-Qualität überarbeitet. Dabei hilft der bereits definierte Test zu überprüfen, ob die Funktionalität nach dem Refactoring immer noch gegeben ist. 

Ein Testcoverage Tool ermöglicht anschließend zu überprüfen, ob auch alle Teile des Codes durch Tests abgedeckt sind. In diesem Projekt liegt die Testabdeckung zur Zeit der Abgabe bei 98\%. Die restlichen 2\% betreffen überwiegend das Loggen von evtl. auftretenden \class{IOExceptions}, die nicht extra für Tests erzeugt wurden.

Um die Tests eines Codeteiles besser von dem Verhalten des restlichen Codes trennen zu können, wurde zudem das Mocking Framework \emph{Mockito} verwendet. Das ermöglicht es, für Klassen und Interfaces eine Art Attrappe zu erzeugen, für die dann konfiguriert werden kann, wie er auf bestimmte Methodenaufrufe mit den korrekten Argumenten reagiert. Zum Einen kann dadurch der zu testende Code besser isoliert werden, weil keine Abhängigkeiten zu anderen Klassen existieren. Es kann aber auch überprüft werden, ob die Aufrufe richtig stattgefunden haben, ob also die Interaktion mit dem Mock-Objekt so ablief, wie erwartet. Dadurch lässt sich auch die Integration in den restlichen Softwareaufbau gut testen.
\begin{lstlisting}[caption={Testbeispiel mit Mockito. Das Maze verwendet ein Mock Objekt von \class{PlayerModelInterface} (Zeile 8) und testet, ob das Verkaufen einer Mauer die Mauer wirklich entfernt (Zeile 21) und dem Spieler den richtigen Geldwert gibt (Zeile 22).},captionpos=b]
public class MazeTest {
  MazeModelInterface maze;
  PlayerModelInterface playerMock;
  int x, y;

	@Before
	public void setup() {
		playerMock = Mockito.mock(Player.class);
		maze = new Maze();
		maze.setPlayerModel(playerMock);
		x = 2;
		y = 3;
	}

	@Test
	public void sellShouldEarnMoneyTest() {
		ObservableList<Wall> walls = maze.getWalls();
		Wall wall = maze.buildWall(x, y);
		assertTrue("maze contains built wall", walls.contains(wall));
		maze.sell(wall);
		assertFalse("Maze shouldn't contain the wall after sell", walls.contains(wall));
		Mockito.verify(playerMock, Mockito.times(1)).earnMoney(wall.getCosts());
	}
}
\end{lstlisting}
% subsection testgetriebene_entwicklung (end)


\subsection{JavaFX} % (fold)
\label{sub:javafx}
Für die Umsetzung der Benutzeroberfläche wurde JavaFX verwendet, das durch die Abwandlung des Observer-Patterns auch viel Einfluss auf den Softwareentwurf hatte (siehe Kapitel \ref{sub:observer}). Das Framework ermöglichte eine modern wirkende Oberfläche durch viele vorgefertigte Komponenten und zahlreiche verfügbare Erweiterungen, wie z. B. ein Popup-Menü. Dabei wird die Komplexität von Swing für ansprechende Layouts deutlich reduziert und das meiste geschieht für den Programmierer unsichtbar im Hintergrund. Zudem existiert für JavaFX Anwendungen das Projekt \emph{javafxports}, das ermöglicht, den gesamten Code ohne große Anpassungen direkt in Mobile Apps zu packen.

Bei der testgetriebenen Entwicklung ist die View-Programmierung meistens eine Herausforderung, da sie schwer Unit-Testbar ist. Hierfür konnte jedoch mit \emph{TestFX} (\url{https://github.com/TestFX/TestFX}) ein gutes Framework verwendet werden, das eine schnelle und anschauliche Implementierung von Unit-Tests für JavaFX ermöglicht. Dadurch konnte auch die korrekte Reaktion auf (erwartete) Userinteraktionen überprüft werden.
\begin{lstlisting}[caption={Beispielcode von TestFX. Das Setup wurde aus Platzgründen nicht aufgeführt, ist aber im Code in der Abstrakten Oberklasse aller ViewTests \class{AbstractViewTest} zu finden. TestFX ermöglicht die Simulation von Mausklicks (Zeile 3, 9 und 15), Bewegungen (Zeile 14) und ermöglicht Überprüfungen der Auswirkung (z.B Zeilen 5-7). Die Methode collectInfos() sammelt bei Fehlschlagen der Überprüfung bisherige Events und erstellt einen Screenshot der Situation für leichtere Problembehandlung.}, captionpos=b]
@Test
public void buildWallOnClick() {
  clickOn("#maze");
  assertEquals("There should be a wall now", 1, maze.getWalls().size());
  verifyThat("#maze", NodeMatchers.hasChildren(1, ".wall"), collectInfos());
  verifyThat(".wall", NodeMatchers.isVisible(), collectInfos());
  verifyThat("#maze .wall", NodeMatchers.hasChildren(1, ".wall-image"), collectInfos());
  // second click: on already existing wall
  clickOn(MouseButton.PRIMARY);
  assertEquals("There should still be only one wall", 1, maze.getWalls().size());
  verifyThat("#maze", NodeMatchers.hasChildren(1, ".wall"), collectInfos());

  // third click: somewhere else
  moveBy(200,0);
  clickOn(MouseButton.PRIMARY);
  assertEquals("There should be two walls now", 2, maze.getWalls().size());
  verifyThat("#maze", NodeMatchers.hasChildren(2, ".wall"), collectInfos());
}	
\end{lstlisting}
Die Tests konnten dabei mit dem von \emph{TestFX} angebotenen \emph{Monocle} Build und geeigneten Systemvariablen in einem \enquote{headless} Zustand ausgeführt werden. Das heißt, dass die Tests nicht tatsächlich die Maus des ausführenden Nutzers bewegen, sondern in einem unsichtbaren Fenster im Hintegrund ausgeführt werden.\footnote{Die Systemvariablen sind \texttt{-Dtestfx.robot=glass -Dtestfx.headless=true -Dprism.order=sw -Dprism.text=t2k -Djava.awt.headless=true -Dtestfx.setup.timeout=10000}}
% subsection javafx (end)
% section entwicklungsprozess (end)